[{"content":"🛠️ Why I Hacked GoPro Plus Cloud? If you\u0026rsquo;re a GoPro Plus user, you’ve probably felt the frustration of trying to download your media in bulk, only to be stopped by the 25-file limit. This arbitrary restriction makes it tedious 😤😡 to migrate your content to other platforms like Google Drive, Dropbox, or your self-hosted NAS (e.g. Synology).\nSo I decided to build a solution that lets you bypass this limitation and take full control of your media. Today, I’ll walk you through what the tool does, how you can use it, and why this matters for anyone looking to break free ⛓️‍💥 from proprietary cloud ecosystems.\nLet’s dive in! 🎉\n🔧 What This Tool Can Do? The GoPro Cloud Downloader is a simple yet powerful Python-based solution that allows you to:\n⬇️ Download Your Entire GoPro Library in One Go: Forget the 25-file restriction! Download hundreds (or thousands) of files from GoPro Plus without lifting a finger. 💸 Migrate Your Media Anywhere: Transfer your media seamlessly to platforms like Google Drive, Dropbox, or a self-hosted solution NAS (like Synology). ⚡ Automate Bulk Downloads: With this tool, you can script and schedule downloads to keep your offline backups up to date. 🐳 Run it in Seconds with Docker: No need to mess with Python code—just pull the Docker image and start downloading. 🐳 Why Docker? For non-developers or anyone who doesn’t want to fiddle with code, I made this tool Docker-friendly. Using the official Docker image, you can get started in no time:\nPull the Docker Image: docker pull itsankoff/gopro Obtain your GoPro Plus Cloud credentials using the following guide Run the Container: docker run -e AUTH_TOKEN=\u0026lt;gopro-auth-token\u0026gt; -e USER_ID=\u0026lt;gopro-user-id\u0026gt; -v \u0026lt;/path/to/download\u0026gt;:/app/download itsankoff/gopro:latest Full reference of the parameters and environment variables can be found here 🔍 How It Works? This tool interacts with the undocumented GoPro Plus API, emulating how the GoPro app communicates with the cloud. It bypasses the limitations of their web UI and allows you to:\nAuthenticate via JWE: Log into your GoPro Plus account securely. Retrieve Media Metadata: Get a list of all your files, regardless of batch size. Download Files in Bulk: Specify the number of files or download them all at once. With these features, you can effortlessly move your media to another storage solution or simply create an offline backup.\n👩‍💻👨‍💻 For Developers If you prefer working with the code directly, head over to the GitHub repository to clone and tweak the project to your liking.\nInstall and Run Locally Clone the repository: git clone https://github.com/itsankoff/gopro-plus Follow the README.md local setup guide Run: ./gopro or make to explore the dev options But again—why code when you can Docker? 🐳\n🤔 Who Is This For? This tool is perfect for:\n🎥 Content Creators: Looking to offload large libraries to more affordable or flexible storage. 🛠️ Tech Enthusiasts: Interested in self-hosted solutions like Synology or a custom NAS. 🐼 Non-Coders: Want a quick, no-fuss way to manage GoPro Plus media using Docker. 🔗 Links and Resources GitHub Repository: itsankoff/gopro-plus Docker Image: itsankoff/gopro 💪 Take Back Control The 25-file limit shouldn’t dictate how you manage your own media. With the GoPro Plus API tool, you can break free from cloud restrictions and enjoy the freedom to store your files wherever you want.\nGive it a try and let me know how it works for you! Drop your feedback in the comments or open an issue on GitHub. ✨\n","permalink":"https://thetooth.io/blog/gopro-plus-downloader/","summary":"\u003ch2 id=\"-why-i-hacked-gopro-plus-cloud\"\u003e🛠️ Why I Hacked GoPro Plus Cloud?\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;re a GoPro Plus user, you’ve probably felt the frustration of trying to download your media in bulk,\nonly to be stopped by the \u003cstrong\u003e25-file limit\u003c/strong\u003e. This arbitrary restriction makes it tedious 😤😡 to migrate\nyour content to other platforms like Google Drive, Dropbox, or your self-hosted NAS (e.g. Synology).\u003c/p\u003e\n\u003cp\u003eSo I decided to build a solution that lets you bypass this limitation and take full control of your media.\nToday, I’ll walk you through what the tool does, how you can use it,\nand why this matters for anyone looking to break free ⛓️‍💥 from proprietary cloud ecosystems.\u003c/p\u003e","title":"⛓️‍💥 Breaking the 25 File Limit on GoPro Plus Cloud"},{"content":"✨ Introduction Welcome to Part 2 of the OpenVPN server series! 🎉 If you’ve gone through the manual setup guide, you know that setting up an OpenVPN server manually can be a bit tedious. 🤔\nBut what if you could automate the entire process? 💡 This guide introduces an Ansible playbook that takes care of everything—from installing dependencies to configuring the OpenVPN server and generating client certificates.\n🛠 Prerequisites Before diving in, ensure you have the following ready:\n🖥 A Ubuntu 20.04LTS 22.04LTS or 24.04LTS server (it should work for older versions or other Ubuntu flavor 🤞). 🔑 SSH access to the server. ⚙️ Ansible installed on your local machine. 🔄 Why Automate? While the manual approach teaches you the nitty-gritty of OpenVPN, automation brings the following perks:\n🕒 Time-saving: Get up and running in minutes. 📜 Repeatability: Easily redeploy or migrate your server. 📦 Manageability: Scale with minimal effort. 🚀 Getting Started with the Ansible Playbook Here’s how you can automate the OpenVPN setup process:\n1️⃣ Clone the Repository First, clone the repository containing the playbook:\ngit clone https://github.com/itsankoff/ansible cd ansible/ansible 2️⃣ Prepare Your Inventory Update your inventory file (hosts) to specify the target server:\n# VPN hosts [vpn] # targer_server_IP | target_server_user | sudo_enabled | ssh_private_key_for_access \u0026lt;server_IP\u0026gt; ansible_user=\u0026lt;user\u0026gt; ansible_become=true ansible_ssh_private_key_file=\u0026lt;path/to/ssh/key\u0026gt; Replace \u0026lt;server_IP\u0026gt;, \u0026lt;user\u0026gt;. Depending on your access to the server either provide path to the SSH private key file in ansible_ssh_private_key_file or delete it if you use SSH with password access (strongly discouraged)\n3️⃣ Configure Variables Add the users you want to generate VPN configurations for in group_vars/openvpn.yml:\nopenvpn_users: - name: \u0026#34;janedoe\u0026#34; state: \u0026#34;active\u0026#34; - name: \u0026#34;johndoe\u0026#34; state: \u0026#34;revoked\u0026#34; If the state is active, the user will have generated certificate and \u0026lt;user\u0026gt;.ovpn configuration.\nIn case you want to stop access to the VPN for some users, use state revoked and rerun the VPN playbook.\n4️⃣ Run the Playbook Run the Ansible playbook to set up the OpenVPN server:\n# from ansible/ansible directory execute ./deploy.sh live openvpn Grab a coffee ☕ while Ansible takes care of everything.\n🧾 What the Playbook Does The playbook performs the following steps:\nInstall dependencies: Installs OpenVPN, EasyRSA, and other prerequisites. Configure EasyRSA: Sets up the public key infrastructure (PKI). Generate certificates: Builds the server and client certificates. Set up networking: Configures IP forwarding and iptables rules. Deploy server configuration: Creates the OpenVPN server configuration. Start OpenVPN: Enables and starts the OpenVPN service. 🎉 Generating Client Configurations The ready OVPN configurations will bee stored in two places:\nOn the target server in /etc/openvpn/client-configs dir. On the local machine into ansible/ansible/files/\u0026lt;user\u0026gt;.ovpn NOTE: ovpn files are gitignored for safety. 🛠 Customization and Details If you need slightly different setup of the server you can check all of the control variables in ansible/ansible/group_vars/openvpn.yml but here a quick reference guide for the most important ones and their default values:\nVariable Description Default Value openvpn_port Port for OpenVPN server 1194 openvpn_proto Protocol (UDP/TCP) udp openvpn_network Subnet for VPN clients 10.8.0.0 openvpn_users List of users and their states (active) N/A ca_common_name Common Name for the Certificate Authority OpenVPN Server easyrsa_dir Directory for EasyRSA setup /etc/openvpn/easy-rsa 🐞 Troubleshooting Problem: No internet on the client\n1. Ensure iptables rules are correctly applied.\n# Run on the VPN server ip route Expected output should look like this:\ndefault via \u0026lt;server_ip\u0026gt; dev eth0 10.8.0.0/24 dev tun0 proto kernel scope link src 10.8.0.1 2. Check that sysctl enables IP forwarding:\nRun on the VPN server\nsudo sysctl net.ipv4.ip_forward Expected output should look like this:\nnet.ipv4.ip_forward=1 3. Monitor Packet Flow\nClient to VPN server traffic\nsudo tcpdump -i tun0 VPN server to public internet traffic\nsudo tcpdump -i eth0 Connect to the VPN server with the client configuration and run ping google.com on the client terminal or open Google in the browser.\nIf the tcpdump for tun0 does not produce logs, then the problem is between client and the VPN service Inspect the client config for proto (udp or tcp. it must match the server configuration) Inspect the client config for remote (it must match server IP) Inspect the client config for port (it must match server IP. Make sure the port is open on the server telnet \u0026lt;server_ip\u0026gt; \u0026lt;port\u0026gt;) If the tcpdump for eth0 does not produce logs, then the problem is either in kernel ip forwarding configuration or within firewall rules (iptables or ufw) Inspect: iptables -t nat -L POSTROUTING -v The result should look like this: MASQUERADE all -- 10.8.0.0/24 anywhere Add Explicit Forwarding Rules: sudo iptables -A FORWARD -i tun0 -o eth0 -j ACCEPT sudo iptables -A FORWARD -i eth0 -o tun0 -m state --state RELATED,ESTABLISHED -j ACCEPT Reinforce NAT Rules for OpenVPN Ensure the MASQUERADE rule for tun0 traffic is correct: sudo iptables -t nat -I POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE Note: Using -I ensures the rule is inserted at the top of the chain, taking precedence over any other rules.\nIf you are interested in more in-depth knowledge around networking and firewalls, check the following articles:\nNetworking 101 Linux Network Tooling Linux Firewalls Linux Modern Firewalls 🌟 Conclusion With this automated setup, you can focus on what matters—using your VPN! 🎉 If you have any feedback or issues, feel free to reach out or open an issue on GitHub. Happy automating! 🚀\n","permalink":"https://thetooth.io/blog/openvpn-server-automation/","summary":"\u003ch2 id=\"-introduction\"\u003e✨ Introduction\u003c/h2\u003e\n\u003cp\u003eWelcome to \u003cstrong\u003ePart 2\u003c/strong\u003e of the OpenVPN server series! 🎉 If you’ve gone through the \u003ca href=\"https://thetooth.io/blog/openvpn-server-setup/\"\u003emanual setup guide\u003c/a\u003e, you know that setting up an OpenVPN server manually can be a bit tedious. 🤔\u003c/p\u003e\n\u003cp\u003eBut what if you could automate the entire process? 💡 This guide introduces an \u003cstrong\u003eAnsible playbook\u003c/strong\u003e that takes care of everything—from installing dependencies to configuring the OpenVPN server and generating client certificates.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-prerequisites\"\u003e🛠 Prerequisites\u003c/h2\u003e\n\u003cp\u003eBefore diving in, ensure you have the following ready:\u003c/p\u003e","title":"🚀 Automating OpenVPN Server Setup with Ansible"},{"content":"In this post, we will walk through the steps of setting up an OpenVPN server on an Ubuntu 20.04, 22.04 or 24.04 machine (it should work for older versions as well 🤞). Additionally, we will provide some context around VPNs, EasyRSA, and the cryptographic mechanisms involved in the process.\nIntroduction to VPN and OpenVPN A VPN, or Virtual Private Network, is a technology that allows you to create a secure connection over the internet. OpenVPN is an open-source VPN protocol that is widely used for creating VPN servers and clients.\nEasyRSA EasyRSA is a command-line tool that is used for managing Public Key Infrastructure (PKI). In the context of OpenVPN, EasyRSA is used to create and manage the cryptographic keys and certificates that are required for a secure VPN connection.\nSetting Up an OpenVPN Server with EasyRSA 3 Here are the steps to set up an OpenVPN server with EasyRSA 3 on an Ubuntu 20.04 server.\nStep 1: Install OpenVPN and EasyRSA sudo apt update sudo apt install -y openvpn easy-rsa Step 2: Set Up the EasyRSA Public Key Infrastructure (PKI) make-cadir ~/easy-rsa cd ~/easy-rsa Step 3: Initialize the PKI ./easyrsa init-pki Step 4: Generate the Certificate Authority (CA) Certificate and Key ./easyrsa build-ca Step 5: Generate the Server Certificate and Key ./easyrsa gen-req server Step 6: Sign the Server Certificate with the CA Certificate ./easyrsa sign-req server server Step 7: Generate Diffie-Hellman Parameters ./easyrsa gen-dh Step 8: Generate the TLS Auth Key openvpn --genkey --secret ta.key Step 9: Copy the Certificates and Keys to the OpenVPN Server Directory sudo cp pki/ca.crt /etc/openvpn/ sudo cp pki/issued/server.crt /etc/openvpn/ sudo cp pki/private/server.key /etc/openvpn/ sudo cp pki/dh.pem /etc/openvpn/ sudo cp ta.key /etc/openvpn/ Step 10: Create the OpenVPN Server Configuration File Create a new file at /etc/openvpn/server.conf and add the following content, modifying it according to your needs:\n# the port number on which the server will listen for incoming VPN connections port 1194 # the protocol to be used for the VPN connection (either udp or tcp) proto udp # specifies that we are using a routed tunnel interface dev tun # path to the Certificate Authority (CA) certificate ca /path/to/ca.crt # path to the server\u0026#39;s certificate cert /path/to/server.crt # path to the server\u0026#39;s private key key /path/to/server.key # path to the Diffie-Hellman parameters file dh /path/to/dh.pem # path to the TLS authentication key and its direction (0 = server, 1 = client) tls-auth /path/to/ta.key 0 # the IP address range to be used for client VPN connections server 10.8.0.0 255.255.255.0 # file to persistently store the IP addresses of connected clients ifconfig-pool-persist ipp.txt # push options to redirect the client\u0026#39;s default gateway, bypassing DHCP push \u0026#34;redirect-gateway def1 bypass-dhcp\u0026#34; # push options to specify the DNS servers to be used by the VPN clients push \u0026#34;dhcp-option DNS 8.8.8.8\u0026#34; push \u0026#34;dhcp-option DNS 8.8.4.4\u0026#34; # allow communication between VPN clients client-to-client # allow multiple clients to connect with the same certificate duplicate-cn # keepalive ping and timeout keepalive 10 120 # encryption cipher to be used for the VPN connection cipher AES-256-CBC # hash algorithm to be used for HMAC authentication auth SHA256 # user and group to drop privileges to after startup user nobody group nogroup # persist the key across tunnel restarts persist-key # persist the tunnel device across tunnel restarts persist-tun # path to the log file for connection status status openvpn-status.log # verbosity level of OpenVPN log output (3 is the default) verb 3 # notify the client to exit when the VPN connection is terminated explicit-exit-notify 1 Step 11: Start the OpenVPN Server sudo systemctl start openvpn@server sudo systemctl enable openvpn@server Your OpenVPN server is now up and running! The next steps would be to generate client certificates and configure the OpenVPN client accordingly.\nStep 12: Configure OpenVPN Client For each client, you will need to create a client certificate and key. Follow these steps to configure the OpenVPN client.\nBuild the client certificate and key: ./easyrsa build-client-full \u0026lt;name\u0026gt; nopass Create a new OpenVPN client configuration file: sudo vim \u0026lt;name\u0026gt;.ovpn You have two options to create the client OpenVPN configuration (.ovpn) - standard and portable.\nStandard - the standard one refers to the ca cert, client cert, client key, tls-auth key as separate files. Here is a basic configuration: # configures the OpenVPN client mode client # specifies that we are using a routed tunnel interface dev tun # specifies that we are using the UDP protocol. (TCP is supported as well) # Both server and client need to match protocol (either UDP or TCP) proto udp # specifies the IP address and port of the OpenVPN server. 1194 is the standard port for UDP remote YOUR_SERVER_IP 1194 # specifies that the client should keep trying to resolve the server IP indefinitely resolv-retry infinite # allows the client to choose any available UDP port nobind # user that the client will run the openvpn client user nobody # group that the client will run the openvpn client group nogroup # persists the key across tunnel restarts persist-key # persists the tunnel device across tunnel restarts persist-tun # links to the CA certificate ca /path/to/ca.crt # links to the client certificate cert /path/to/\u0026lt;name\u0026gt;.crt # links to the client private key (NOTE: Keep the key in secret) key /path/to/\u0026lt;name\u0026gt;.key # The TLS authentication key adds an extra layer of HMAC authentication to the TLS control channel tls-auth /path/to/ta.key 1 # ensures that the server certificate was signed by a trusted CA (specified in the ca option) remote-cert-tls server # specifies the encryption cipher to be used for the VPN connection cipher AES-256-CBC # specifies the hash algorithm to be used for HMAC authentication auth SHA256 # specifies the verbosity level of OpenVPN log output verb 3 Portable - the portable one embeds the ca cert, client cert, client key, tls-auth key in the ovpn config file so you can move it around without the need to copy other files as well. Here is a basic configuration: # configures the OpenVPN client mode client # specifies that we are using a routed tunnel interface dev tun # specifies that we are using the UDP protocol. (TCP is supported as well) # Both server and client need to match protocol (either UDP or TCP) proto udp # specifies the IP address and port of the OpenVPN server. 1194 is the standard port for UDP remote YOUR_SERVER_IP 1194 # specifies that the client should keep trying to resolve the server IP indefinitely resolv-retry infinite # allows the client to choose any available UDP port nobind # user that the client will run the openvpn client user nobody # group that the client will run the openvpn client group nogroup # persists the key across tunnel restarts persist-key # persists the tunnel device across tunnel restarts persist-tun # ensures that the server certificate was signed by a trusted CA (specified in the ca option) remote-cert-tls server # specifies the encryption cipher to be used for the VPN connection cipher AES-256-CBC # specifies the hash algorithm to be used for HMAC authentication auth SHA256 # specifies the verbosity level of OpenVPN log output verb 3 # links to the CA certificate # embed the Certificate Authority certificate \u0026lt;ca\u0026gt; # insert the contents of your ca.crt file here /path/to/pki/ca.cert \u0026lt;/ca\u0026gt; # links to the client certificate # embed the client certificate \u0026lt;cert\u0026gt; # insert the contents of your /path/to/pki/issued/\u0026lt;name\u0026gt;.crt here \u0026lt;/cert\u0026gt; # links to the client private key # embed the client key \u0026lt;key\u0026gt; # insert the contents of your /path/to/pki/private/\u0026lt;name\u0026gt;.key file here \u0026lt;/key\u0026gt; # the TLS authentication key adds an extra layer of HMAC authentication to the TLS control channel # embed the TLS authentication key for additional security \u0026lt;tls-auth\u0026gt; # insert the contents of your /path/to/openvpn-ca/ta.key file here \u0026lt;/tls-auth\u0026gt; # this tells OpenVPN that the ta.key is embedded in the configuration file # and should be used for HMAC authentication as a client. tls-auth inline 1 Save and exit. Download the \u0026lt;name\u0026gt;.ovpn configuration and use some of the popular vpn clients that support OpenVPN: Windows Linux MacOS, TunnelBlick, Viscosity Now you are good to go! You can surf the internet securely.\n(Optional) Gift If you don\u0026rsquo;t want to re-read this tutorial to issue client configurations once in a while because you don\u0026rsquo;t remember and command exec sequence, here is a quick Makefile that will simplify the creation of a client configuration.\nGo to /path/to/openvpn-ca vim Makefile Paste the following content: SHELL := /bin/bash CLIENT ?= client1 EASYRSA_DIR ?= . PKI_DIR ?= $(EASYRSA_DIR)/pki TA_KEY ?= $(EASYRSA_DIR)/ta.key OUTPUT_DIR ?= $(EASYRSA_DIR)/clients OVPN_TEMPLATE ?= $(OUTPUT_DIR)/client.ovpn.template .PHONY: help client help: @echo \u0026#34;Usage:\u0026#34; @echo \u0026#34; make client CLIENT=\u0026lt;client_name\u0026gt;\u0026#34; @echo \u0026#34; Generates an OpenVPN client configuration file for the specified client.\u0026#34; @echo \u0026#34; If \u0026lt;client_name\u0026gt; is not provided, \u0026#39;client1\u0026#39; is used as the default.\u0026#34; client: @mkdir -p $(OUTPUT_DIR) @$(EASYRSA_DIR)/easyrsa build-client-full $(CLIENT) nopass @cat $(OVPN_TEMPLATE) \u0026gt; $(OUTPUT_DIR)/$(CLIENT).ovpn @echo -e \u0026#34;\u0026lt;ca\u0026gt;\\n$$(cat $(PKI_DIR)/ca.crt)\\n\u0026lt;/ca\u0026gt;\\n\u0026lt;cert\u0026gt;\\n$$(cat $(PKI_DIR)/issued/$(CLIENT).crt)\\n\u0026lt;/cert\u0026gt;\\n\u0026lt;key\u0026gt;\\n$$(cat $(PKI_DIR)/private/$(CLIENT).key)\\n\u0026lt;/key\u0026gt;\\n\u0026lt;tls-auth\u0026gt;\\n$$(cat $(TA_KEY))\\n\u0026lt;/tls-auth\u0026gt;\u0026#34; \u0026gt;\u0026gt; $(OUTPUT_DIR)/$(CLIENT).ovpn @echo \u0026#34;Client configuration for $(CLIENT) created at $(OUTPUT_DIR)/$(CLIENT).ovpn\u0026#34; default: help Save and exit Whenever you need to issue a new client configuration you can just run:\nmake client CLIENT=\u0026lt;name\u0026gt; If you forget the make client CLIENT=\u0026lt;name\u0026gt; command execution, just run make and it will print you the help section.\nTroubleshooting If you receive similar messages on the server side: ovpn-server[460342]: Authenticate/Decrypt packet error: packet HMAC authentication failed ovpn-server[460342]: TLS Error: incoming packet authentication failed from [AF_INET]\u0026lt;remote_ip\u0026gt;:\u0026lt;remote_port\u0026gt; Most probably the client configuration around tls-auth is not configured correctly. Make sure that the client tls-auth option is set to 1 and the server tls-auth is set to 0.\n","permalink":"https://thetooth.io/blog/openvpn-server-setup/","summary":"\u003cp\u003eIn this post, we will walk through the steps of setting up an OpenVPN server on\nan Ubuntu 20.04, 22.04 or 24.04 machine (it should work for older versions as well 🤞). Additionally, we will provide some context around VPNs,\nEasyRSA, and the cryptographic mechanisms involved in the process.\u003c/p\u003e\n\u003ch2 id=\"introduction-to-vpn-and-openvpn\"\u003eIntroduction to VPN and OpenVPN\u003c/h2\u003e\n\u003cp\u003eA VPN, or Virtual Private Network, is a technology that allows you to create\na secure connection over the internet. OpenVPN is an open-source VPN protocol\nthat is widely used for creating VPN servers and clients.\u003c/p\u003e","title":"🛡️ Setting Up an OpenVPN Server with EasyRSA 3"},{"content":"Apart from being the cutest animal in the world 😍, Slowloris is also a low-bandwidth Denial-of-Service (DoS) attack running on Application layer of the OSI model (OSI Layer 7). The attack allows the attacker to overwhelm a target HTTP server by exploiting the internals of the HTTP protocol.\nHow does a normal HTTP request-response work? In a normal scenario the client opens a TCP connection after which it sends the text information for the request. Each of the request\u0026rsquo;s lines are terminated by \\r\\n (so-called CRLF - carriage return line feed ⌨️) sequence. The end of the request is signaled by \\r\\n\\r\\n.\nClient (Alice) sends a HTTP GET request to a HTTP Server (Bob) The first line in the HTTP request is called request line holding information about the HTTP request method GET, path / and query parameters (?key=value\u0026amp;hello=world) as well as protocol version HTTP/1.1. Then the client starts sending the request headers (Host: example.com, User-Agent: ...) and so on. In the end the client sends \\r\\n\\r\\n to notify the server that the request is done.\nHow does a Slowloris attack works? Slowloris attack works by utilizing partial HTTP requests. HTTP protocol works as opening a client TCP connection to a target server and then sends the HTTP request. The server usually waits until it receives the \\r\\n\\r\\n sequence to process the request. Here comes the attack exploit. The attacker can send multiple headers (thousands) to keep the connection open. By opening multiple such connections and regularly sending partial information (such as headers) the memory and sockets start building up on the server side. This way the client can easily exhaust server\u0026rsquo;s available resources (ports, sockets and memory). Once the server\u0026rsquo;s maximum connections has been exceeded, each new connection won\u0026rsquo;t be answered and denial-of-service will occur. Server configurations Usually HTTP servers support configuration parameters like running workers/threads, maximum open connections, timeouts and so on. The problem comes when a server runs with the obsolete defaults configuration or it is inherently exposed to such attack by its internal implementation.\nApache server The Apache server implementation is a thead-based implementation which is inherently vulnerable to attacks like slowloris. The problem comes with that the OS defines number of of maximum threads for each process. The numbers nowadays are pretty big cat /proc/sys/kernel/threads-max but still if you don\u0026rsquo;t have access to kernel configuration that may be an issue. Another problem is memory footprint. Each OS thread is associated with memory and also there are restrictions of maximum Virtual Memory Areas (VMAs) per process cat /proc/sys/vm/max_map_count. If the server does not have any additional protection through custom configuration an attacker with very little bandwidth (slowloris attack) can easily exhaust system\u0026rsquo;s resources and create a denial-of-service scenario.\nNginx server Difference here is that the Nginx implementation relies on event based system which saves the server from attacks such slowloris. But the problem may come from having a Nginx server running its default configuration. Nowadays Nginx comes with a default configuration that is pretty obsolete and it is usually vulnerable to slowloris attack.\nWant to play with slowloris? If you want to explore whether some of your deployments are vulnerable or susceptible to slowloris attack, I\u0026rsquo;ve created a distributed Golang implementation. The tools is able to run thousands of parallel slowloris connections against a target server. You can download it and find more in the 🪣 repo\nIn the next article we will look at how to protect from such attacks.\nBest! 🦷\n","permalink":"https://thetooth.io/blog/slowloris-attack/","summary":"\u003cp\u003eApart from being the cutest animal in the world 😍,\nSlowloris is also a low-bandwidth \u003cstrong\u003eD\u003c/strong\u003eenial-\u003cstrong\u003eo\u003c/strong\u003ef-\u003cstrong\u003eS\u003c/strong\u003eervice (DoS) attack\nrunning on Application layer of the\n\u003ca href=\"https://en.wikipedia.org/wiki/OSI_model\"\u003eOSI model\u003c/a\u003e (OSI Layer 7). The attack\nallows the attacker to overwhelm a target HTTP server by exploiting the\ninternals of the \u003ca href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol\"\u003eHTTP protocol\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"how-does-a-normal-http-request-response-work\"\u003eHow does a normal HTTP request-response work?\u003c/h2\u003e\n\u003cp\u003eIn a normal scenario the client opens a TCP connection after which it sends the\ntext information for the request. Each of the request\u0026rsquo;s \u003ccode\u003elines\u003c/code\u003e are terminated\nby \u003ccode\u003e\\r\\n\u003c/code\u003e (so-called \u003ccode\u003eCRLF\u003c/code\u003e - carriage return line feed ⌨️) sequence.\nThe end of the request is signaled by \u003ccode\u003e\\r\\n\\r\\n\u003c/code\u003e.\u003c/p\u003e","title":"🦥 Slowloris Attack"},{"content":"If you are landing on this page you probably already know what SSH is and how to use it through CLI. If not, take a quick look here. In general, SSH is the most common tool people use to connect to remote systems and servers.\nUsually, in the beginning, a user starts with simple ssh \u0026lt;user\u0026gt;@\u0026lt;host\u0026gt; CLI usage. With time, using more and more advanced options, the commands become lengthy and clumsy resulting in a mess that is hard or impossible to remember.\nLet\u0026rsquo;s give you an example:\n# My SSH life begins here ssh user@host # :) - \u0026#34;That was easy\u0026#34; # Then some person decides to enforce security through obscurity ssh user@this.is.a.super.long.host.that.is.hard.to.remember.private.com # ;) - \u0026#34;Eh mate, you can do better\u0026#34; # Then the same person decides to change the default port ssh -p 43571 user@this.is.a.super.long.host.that.is.hard.to.remember.private.com # X) - \u0026#34;I am pretty good at numerology\u0026#34; # That\u0026#39;s not enough, so let\u0026#39;s disable password auth and # enforce public/private key authentication only ssh -p 43571 -i /where/the/heck/is/my/private/key user@this.is.a.super.long.host.that.is.hard.to.remember.private.com # :| - \u0026#34;Grr...\u0026#34; # somebody from the infra team: # \u0026#34;Mmm, the security team asked us to put everything in a private network # and you will need an access the server through our jump server\u0026#34; ssh -J jumbo@this.is.another.obscure.host.private.jump.com:62891 -i /where/the/heck/is/my/private/key -p 43571 user@this.is.a.super.long.host.that.is.hard.to.remember.private.com # :@ - \u0026#34;Just shut up and teach me about the SSH config file!\u0026#34; Remembering dictionary information nowadays should be considered a crime! So what can you do to make yourself a proper citizen of the world?\nSSH config on the rescue SSH utilities have a ton of options and configuration, so let\u0026rsquo;s try to utilize them and simplify our work! One of them is the SSH config. The SSH config is a configurational file, usually stored at ~/.ssh/config where you can configure hosts and their access options that you use frequently and simplify the access shown above to:\n# access the \u0026#39;this.is.a.super.long.host.that.is.hard.to.remember.private.com\u0026#39; ssh test # access the non-default-port (43571) on you-know-which-host ssh ci # access the production for f@ck sake! ssh prod Setup Check whether you have ~/.ssh/config on your local setup. If the file does not exist, let\u0026rsquo;s create it! NOTE: ~(tilda) means the home directory of the current user. Open the file with a text editor (vim, emacs, VSCode, nano, etc.) Write down: Host \u0026lt;alias\u0026gt; Hostname \u0026lt;[host|ip]\u0026gt; # mandatory Port \u0026lt;port\u0026gt; # optional User \u0026lt;username\u0026gt; # optional | nice-to-have IdentityFile \u0026lt;path/to/identity_file\u0026gt; # optional | nice-to-have ProxyJump \u0026lt;[host|ip]_of_jump_server\u0026gt; # optional Replace the mandatory placeholders and remove the unused ones Save the file Where:\nHostname \u0026lt;[host|ip]\u0026gt; - the DNS host or IP address of the target server Port \u0026lt;port\u0026gt; - you can skip this if the target server runs SSH on the default 22 port. Otherwise, you will need to state it. User \u0026lt;username\u0026gt; - the name of the remote user on the target server you want to connect with. NOTE: Default is your local machine username echo ${USER} IdentifyFile \u0026lt;/path/to/identity_file\u0026gt; - this is the path to the private key you use to connect to the target server. NOTE: Default is ~/.ssh/id_rsa or an iteration of the files within ~/.ssh directory ProxyJump \u0026lt;[host|ip]_of_jump_server\u0026gt; - if you want to connect to the target server using a jump server, you should specify its DNS host or IP address here. There is a ton of other options which you can explore here\nUsage and Access # :) - My SSH life begins again ssh test # ;) - This time way easier ssh ci # X) So easy that I may run \u0026#39;rm -rf /*\u0026#39; to spice it up a bit ssh prod If you have configured everything properly you should be connected to the target server with a clean and easy-to-remember CLI. 🎊\nTroubleshooting In case the setup does not work, there are a few things you can inspect:\n✏️ Make sure you saved ~/.ssh/config 🔎 Check for typos within the ~/.ssh/config ☎️ If using DNS records for hostname configuration, inspect whether your local setup can resolve them nslookup \u0026lt;host\u0026gt; 🔌 If you are not sure whether the configured port is open you can always run nc -G 1 \u0026lt;host|ip\u0026gt; \u0026lt;port\u0026gt;, where -G 1 is one second of timeout. If the operation times out, most probably the port is not open. 🖨️ Check for network access to the target server ping \u0026lt;host\u0026gt;. NOTE: Sometimes admins disable ping, so it may not work. You can use traceroute or nc in that case. 🔓 In case of WARNING: UNPROTECTED PRIVATE KEY FILE! run chmod 0600 /path/to/private/key Wrap-up In the beginning, it may seem an overkill to maintain your SSH config file. But with time and exposure to more servers you will eventually end up using SSH config anyway.\nIn the end - What if you want to create another host for access. Just repeat the steps above and enjoy your day! 🎉\nPS: If you have a friend who struggles with SSH you can always share it with the links down-below ⬇️\nBest! 🦷\n","permalink":"https://thetooth.io/blog/ssh_access/","summary":"\u003cp\u003eIf you are landing on this page you probably already know what SSH is and\nhow to use it through CLI. If not, take a quick look \u003ca href=\"https://en.wikipedia.org/wiki/Secure_Shell\"\u003ehere\u003c/a\u003e.\nIn general, SSH is the most common tool people use to connect to remote systems and servers.\u003c/p\u003e\n\u003cp\u003eUsually, in the beginning, a user starts with simple \u003ccode\u003essh \u0026lt;user\u0026gt;@\u0026lt;host\u0026gt;\u003c/code\u003e CLI usage.\nWith time, using more and more advanced options, the commands become lengthy and clumsy\nresulting in a mess that is hard or impossible to remember.\u003c/p\u003e","title":"📟 SSH access made easy"},{"content":"Init blogpost 🎬\necho Hello World 🦷 ","permalink":"https://thetooth.io/blog/thebeginning/","summary":"\u003cp\u003eInit blogpost 🎬\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eecho Hello World 🦷\n\u003c/code\u003e\u003c/pre\u003e","title":"🎬 The Beginning"}]