[{"content":"In this post, we will walk through the steps of setting up an OpenVPN server on an Ubuntu 20.04 machine. Additionally, we will provide some context around VPNs, EasyRSA, and the cryptographic mechanisms involved in the process.\nIntroduction to VPN and OpenVPN A VPN, or Virtual Private Network, is a technology that allows you to create a secure connection over the internet. OpenVPN is an open-source VPN protocol that is widely used for creating VPN servers and clients.\nEasyRSA EasyRSA is a command-line tool that is used for managing Public Key Infrastructure (PKI). In the context of OpenVPN, EasyRSA is used to create and manage the cryptographic keys and certificates that are required for a secure VPN connection.\nSetting Up an OpenVPN Server with EasyRSA 3 Here are the steps to set up an OpenVPN server with EasyRSA 3 on an Ubuntu 20.04 server.\nStep 1: Install OpenVPN and EasyRSA sudo apt update sudo apt install -y openvpn easy-rsa Step 2: Set Up the EasyRSA Public Key Infrastructure (PKI) make-cadir ~/easy-rsa cd ~/easy-rsa Step 3: Initialize the PKI ./easyrsa init-pki Step 4: Generate the Certificate Authority (CA) Certificate and Key ./easyrsa build-ca Step 5: Generate the Server Certificate and Key ./easyrsa gen-req server Step 6: Sign the Server Certificate with the CA Certificate ./easyrsa sign-req server server Step 7: Generate Diffie-Hellman Parameters ./easyrsa gen-dh Step 8: Generate the TLS Auth Key openvpn --genkey --secret ta.key Step 9: Copy the Certificates and Keys to the OpenVPN Server Directory sudo cp pki/ca.crt /etc/openvpn/ sudo cp pki/issued/server.crt /etc/openvpn/ sudo cp pki/private/server.key /etc/openvpn/ sudo cp pki/dh.pem /etc/openvpn/ sudo cp ta.key /etc/openvpn/ Step 10: Create the OpenVPN Server Configuration File Create a new file at /etc/openvpn/server.conf and add the following content, modifying it according to your needs:\n# the port number on which the server will listen for incoming VPN connections port 1194 # the protocol to be used for the VPN connection (either udp or tcp) proto udp # specifies that we are using a routed tunnel interface dev tun # path to the Certificate Authority (CA) certificate ca /path/to/ca.crt # path to the server\u0026#39;s certificate cert /path/to/server.crt # path to the server\u0026#39;s private key key /path/to/server.key # path to the Diffie-Hellman parameters file dh /path/to/dh.pem # path to the TLS authentication key and its direction (0 = server, 1 = client) tls-auth /path/to/ta.key 0 # the IP address range to be used for client VPN connections server 10.8.0.0 255.255.255.0 # file to persistently store the IP addresses of connected clients ifconfig-pool-persist ipp.txt # push options to redirect the client\u0026#39;s default gateway, bypassing DHCP push \u0026#34;redirect-gateway def1 bypass-dhcp\u0026#34; # push options to specify the DNS servers to be used by the VPN clients push \u0026#34;dhcp-option DNS 8.8.8.8\u0026#34; push \u0026#34;dhcp-option DNS 8.8.4.4\u0026#34; # allow communication between VPN clients client-to-client # allow multiple clients to connect with the same certificate duplicate-cn # keepalive ping and timeout keepalive 10 120 # encryption cipher to be used for the VPN connection cipher AES-256-CBC # hash algorithm to be used for HMAC authentication auth SHA256 # user and group to drop privileges to after startup user nobody group nogroup # persist the key across tunnel restarts persist-key # persist the tunnel device across tunnel restarts persist-tun # path to the log file for connection status status openvpn-status.log # verbosity level of OpenVPN log output (3 is the default) verb 3 # notify the client to exit when the VPN connection is terminated explicit-exit-notify 1 Step 11: Start the OpenVPN Server sudo systemctl start openvpn@server sudo systemctl enable openvpn@server Your OpenVPN server is now up and running! The next steps would be to generate client certificates and configure the OpenVPN client accordingly.\nStep 12: Configure OpenVPN Client For each client, you will need to create a client certificate and key. Follow these steps to configure the OpenVPN client.\nBuild the client certificate and key: ./easyrsa build-client-full \u0026lt;name\u0026gt; nopass Create a new OpenVPN client configuration file: sudo vim \u0026lt;name\u0026gt;.ovpn You have two options to create the client OpenVPN configuration (.ovpn) - standard and portable.\nStandard - the standard one refers to the ca cert, client cert, client key, tls-auth key as separate files. Here is a basic configuration: # configures the OpenVPN client mode client # specifies that we are using a routed tunnel interface dev tun # specifies that we are using the UDP protocol. (TCP is supported as well) # Both server and client need to match protocol (either UDP or TCP) proto udp # specifies the IP address and port of the OpenVPN server. 1194 is the standard port for UDP remote YOUR_SERVER_IP 1194 # specifies that the client should keep trying to resolve the server IP indefinitely resolv-retry infinite # allows the client to choose any available UDP port nobind # user that the client will run the openvpn client user nobody # group that the client will run the openvpn client group nogroup # persists the key across tunnel restarts persist-key # persists the tunnel device across tunnel restarts persist-tun # links to the CA certificate ca /path/to/ca.crt # links to the client certificate cert /path/to/\u0026lt;name\u0026gt;.crt # links to the client private key (NOTE: Keep the key in secret) key /path/to/\u0026lt;name\u0026gt;.key # The TLS authentication key adds an extra layer of HMAC authentication to the TLS control channel tls-auth /path/to/ta.key 1 # ensures that the server certificate was signed by a trusted CA (specified in the ca option) remote-cert-tls server # specifies the encryption cipher to be used for the VPN connection cipher AES-256-CBC # specifies the hash algorithm to be used for HMAC authentication auth SHA256 # specifies the verbosity level of OpenVPN log output verb 3 Portable - the portable one embeds the ca cert, client cert, client key, tls-auth key in the ovpn config file so you can move it around without the need to copy other files as well. Here is a basic configuration: # configures the OpenVPN client mode client # specifies that we are using a routed tunnel interface dev tun # specifies that we are using the UDP protocol. (TCP is supported as well) # Both server and client need to match protocol (either UDP or TCP) proto udp # specifies the IP address and port of the OpenVPN server. 1194 is the standard port for UDP remote YOUR_SERVER_IP 1194 # specifies that the client should keep trying to resolve the server IP indefinitely resolv-retry infinite # allows the client to choose any available UDP port nobind # user that the client will run the openvpn client user nobody # group that the client will run the openvpn client group nogroup # persists the key across tunnel restarts persist-key # persists the tunnel device across tunnel restarts persist-tun # ensures that the server certificate was signed by a trusted CA (specified in the ca option) remote-cert-tls server # specifies the encryption cipher to be used for the VPN connection cipher AES-256-CBC # specifies the hash algorithm to be used for HMAC authentication auth SHA256 # specifies the verbosity level of OpenVPN log output verb 3 # links to the CA certificate # embed the Certificate Authority certificate \u0026lt;ca\u0026gt; # insert the contents of your ca.crt file here /path/to/pki/ca.cert \u0026lt;/ca\u0026gt; # links to the client certificate # embed the client certificate \u0026lt;cert\u0026gt; # insert the contents of your /path/to/pki/issued/\u0026lt;name\u0026gt;.crt here \u0026lt;/cert\u0026gt; # links to the client private key # embed the client key \u0026lt;key\u0026gt; # insert the contents of your /path/to/pki/private/\u0026lt;name\u0026gt;.key file here \u0026lt;/key\u0026gt; # the TLS authentication key adds an extra layer of HMAC authentication to the TLS control channel # embed the TLS authentication key for additional security \u0026lt;tls-auth\u0026gt; # insert the contents of your /path/to/openvpn-ca/ta.key file here \u0026lt;/tls-auth\u0026gt; # this tells OpenVPN that the ta.key is embedded in the configuration file # and should be used for HMAC authentication as a client. tls-auth inline 1 Save and exit. Download the \u0026lt;name\u0026gt;.ovpn configuration and use some of the popular vpn clients that support OpenVPN: Windows Linux MacOS, TunnelBlick, Viscosity Now you are good to go! You can surf the internet securely.\n(Optional) Gift If you don\u0026rsquo;t want to re-read this tutorial to issue client configurations once in a while because you don\u0026rsquo;t remember and command exec sequence, here is a quick Makefile that will simplify the creation of a client configuration.\nGo to /path/to/openvpn-ca vim Makefile Paste the following content: SHELL := /bin/bash CLIENT ?= client1 EASYRSA_DIR ?= . PKI_DIR ?= $(EASYRSA_DIR)/pki TA_KEY ?= $(EASYRSA_DIR)/ta.key OUTPUT_DIR ?= $(EASYRSA_DIR)/clients OVPN_TEMPLATE ?= $(OUTPUT_DIR)/client.ovpn.template .PHONY: help client help: @echo \u0026#34;Usage:\u0026#34; @echo \u0026#34; make client CLIENT=\u0026lt;client_name\u0026gt;\u0026#34; @echo \u0026#34; Generates an OpenVPN client configuration file for the specified client.\u0026#34; @echo \u0026#34; If \u0026lt;client_name\u0026gt; is not provided, \u0026#39;client1\u0026#39; is used as the default.\u0026#34; client: @mkdir -p $(OUTPUT_DIR) @$(EASYRSA_DIR)/easyrsa build-client-full $(CLIENT) nopass @cat $(OVPN_TEMPLATE) \u0026gt; $(OUTPUT_DIR)/$(CLIENT).ovpn @echo -e \u0026#34;\u0026lt;ca\u0026gt;\\n$$(cat $(PKI_DIR)/ca.crt)\\n\u0026lt;/ca\u0026gt;\\n\u0026lt;cert\u0026gt;\\n$$(cat $(PKI_DIR)/issued/$(CLIENT).crt)\\n\u0026lt;/cert\u0026gt;\\n\u0026lt;key\u0026gt;\\n$$(cat $(PKI_DIR)/private/$(CLIENT).key)\\n\u0026lt;/key\u0026gt;\\n\u0026lt;tls-auth\u0026gt;\\n$$(cat $(TA_KEY))\\n\u0026lt;/tls-auth\u0026gt;\u0026#34; \u0026gt;\u0026gt; $(OUTPUT_DIR)/$(CLIENT).ovpn @echo \u0026#34;Client configuration for $(CLIENT) created at $(OUTPUT_DIR)/$(CLIENT).ovpn\u0026#34; default: help Save and exit Whenever you need to issue a new client configuration you can just run:\nmake client CLIENT=\u0026lt;name\u0026gt; If you forget the make client CLIENT=\u0026lt;name\u0026gt; command execution, just run make and it will print you the help section.\nTroubleshooting If you receive similar messages on the server side: ovpn-server[460342]: Authenticate/Decrypt packet error: packet HMAC authentication failed ovpn-server[460342]: TLS Error: incoming packet authentication failed from [AF_INET]\u0026lt;remote_ip\u0026gt;:\u0026lt;remote_port\u0026gt; Most probably the client configuration around tls-auth is not configured correctly. Make sure that the client tls-auth option is set to 1 and the server tls-auth is set to 0.\n","permalink":"https://thetooth.io/blog/openvpn-server-setup/","summary":"In this post, we will walk through the steps of setting up an OpenVPN server on an Ubuntu 20.04 machine. Additionally, we will provide some context around VPNs, EasyRSA, and the cryptographic mechanisms involved in the process.\nIntroduction to VPN and OpenVPN A VPN, or Virtual Private Network, is a technology that allows you to create a secure connection over the internet. OpenVPN is an open-source VPN protocol that is widely used for creating VPN servers and clients.","title":"Setting Up an OpenVPN Server with EasyRSA 3"},{"content":"Apart from being the cutest animal in the world 😍, Slowloris is also a low-bandwidth Denial-of-Service (DoS) attack running on Application layer of the OSI model (OSI Layer 7). The attack allows the attacker to overwhelm a target HTTP server by exploiting the internals of the HTTP protocol.\nHow does a normal HTTP request-response work? In a normal scenario the client opens a TCP connection after which it sends the text information for the request. Each of the request\u0026rsquo;s lines are terminated by \\r\\n (so-called CRLF - carriage return line feed ⌨️) sequence. The end of the request is signaled by \\r\\n\\r\\n.\nClient (Alice) sends a HTTP GET request to a HTTP Server (Bob) The first line in the HTTP request is called request line holding information about the HTTP request method GET, path / and query parameters (?key=value\u0026amp;hello=world) as well as protocol version HTTP/1.1. Then the client starts sending the request headers (Host: example.com, User-Agent: ...) and so on. In the end the client sends \\r\\n\\r\\n to notify the server that the request is done.\nHow does a Slowloris attack works? Slowloris attack works by utilizing partial HTTP requests. HTTP protocol works as opening a client TCP connection to a target server and then sends the HTTP request. The server usually waits until it receives the \\r\\n\\r\\n sequence to process the request. Here comes the attack exploit. The attacker can send multiple headers (thousands) to keep the connection open. By opening multiple such connections and regularly sending partial information (such as headers) the memory and sockets start building up on the server side. This way the client can easily exhaust server\u0026rsquo;s available resources (ports, sockets and memory). Once the server\u0026rsquo;s maximum connections has been exceeded, each new connection won\u0026rsquo;t be answered and denial-of-service will occur. Server configurations Usually HTTP servers support configuration parameters like running workers/threads, maximum open connections, timeouts and so on. The problem comes when a server runs with the obsolete defaults configuration or it is inherently exposed to such attack by its internal implementation.\nApache server The Apache server implementation is a thead-based implementation which is inherently vulnerable to attacks like slowloris. The problem comes with that the OS defines number of of maximum threads for each process. The numbers nowadays are pretty big cat /proc/sys/kernel/threads-max but still if you don\u0026rsquo;t have access to kernel configuration that may be an issue. Another problem is memory footprint. Each OS thread is associated with memory and also there are restrictions of maximum Virtual Memory Areas (VMAs) per process cat /proc/sys/vm/max_map_count. If the server does not have any additional protection through custom configuration an attacker with very little bandwidth (slowloris attack) can easily exhaust system\u0026rsquo;s resources and create a denial-of-service scenario.\nNginx server Difference here is that the Nginx implementation relies on event based system which saves the server from attacks such slowloris. But the problem may come from having a Nginx server running its default configuration. Nowadays Nginx comes with a default configuration that is pretty obsolete and it is usually vulnerable to slowloris attack.\nWant to play with slowloris? If you want to explore whether some of your deployments are vulnerable or susceptible to slowloris attack, I\u0026rsquo;ve created a distributed Golang implementation. The tools is able to run thousands of parallel slowloris connections against a target server. You can download it and find more in the 🪣 repo\nIn the next article we will look at how to protect from such attacks.\nBest! 🦷\n","permalink":"https://thetooth.io/blog/slowloris-attack/","summary":"Apart from being the cutest animal in the world 😍, Slowloris is also a low-bandwidth Denial-of-Service (DoS) attack running on Application layer of the OSI model (OSI Layer 7). The attack allows the attacker to overwhelm a target HTTP server by exploiting the internals of the HTTP protocol.\nHow does a normal HTTP request-response work? In a normal scenario the client opens a TCP connection after which it sends the text information for the request.","title":"Slowloris Attack 🦥 "},{"content":"If you are landing on this page you probably already know what SSH is and how to use it through CLI. If not, take a quick look here. In general, SSH is the most common tool people use to connect to remote systems and servers.\nUsually, in the beginning, a user starts with simple ssh \u0026lt;user\u0026gt;@\u0026lt;host\u0026gt; CLI usage. With time, using more and more advanced options, the commands become lengthy and clumsy resulting in a mess that is hard or impossible to remember.\nLet\u0026rsquo;s give you an example:\n# My SSH life begins here ssh user@host # :) - \u0026#34;That was easy\u0026#34; # Then some person decides to enforce security through obscurity ssh user@this.is.a.super.long.host.that.is.hard.to.remember.private.com # ;) - \u0026#34;Eh mate, you can do better\u0026#34; # Then the same person decides to change the default port ssh -p 43571 user@this.is.a.super.long.host.that.is.hard.to.remember.private.com # X) - \u0026#34;I am pretty good at numerology\u0026#34; # That\u0026#39;s not enough, so let\u0026#39;s disable password auth and # enforce public/private key authentication only ssh -p 43571 -i /where/the/heck/is/my/private/key user@this.is.a.super.long.host.that.is.hard.to.remember.private.com # :| - \u0026#34;Grr...\u0026#34; # somebody from the infra team: # \u0026#34;Mmm, the security team asked us to put everything in a private network # and you will need an access the server through our jump server\u0026#34; ssh -J jumbo@this.is.another.obscure.host.private.jump.com:62891 -i /where/the/heck/is/my/private/key -p 43571 user@this.is.a.super.long.host.that.is.hard.to.remember.private.com # :@ - \u0026#34;Just shut up and teach me about the SSH config file!\u0026#34; Remembering dictionary information nowadays should be considered a crime! So what can you do to make yourself a proper citizen of the world?\nSSH config on the rescue SSH utilities have a ton of options and configuration, so let\u0026rsquo;s try to utilize them and simplify our work! One of them is the SSH config. The SSH config is a configurational file, usually stored at ~/.ssh/config where you can configure hosts and their access options that you use frequently and simplify the access shown above to:\n# access the \u0026#39;this.is.a.super.long.host.that.is.hard.to.remember.private.com\u0026#39; ssh test # access the non-default-port (43571) on you-know-which-host ssh ci # access the production for f@ck sake! ssh prod Setup Check whether you have ~/.ssh/config on your local setup. If the file does not exist, let\u0026rsquo;s create it! NOTE: ~(tilda) means the home directory of the current user. Open the file with a text editor (vim, emacs, VSCode, nano, etc.) Write down: Host \u0026lt;alias\u0026gt; Hostname \u0026lt;[host|ip]\u0026gt; # mandatory Port \u0026lt;port\u0026gt; # optional User \u0026lt;username\u0026gt; # optional | nice-to-have IdentityFile \u0026lt;path/to/identity_file\u0026gt; # optional | nice-to-have ProxyJump \u0026lt;[host|ip]_of_jump_server\u0026gt; # optional Replace the mandatory placeholders and remove the unused ones Save the file Where:\nHostname \u0026lt;[host|ip]\u0026gt; - the DNS host or IP address of the target server Port \u0026lt;port\u0026gt; - you can skip this if the target server runs SSH on the default 22 port. Otherwise, you will need to state it. User \u0026lt;username\u0026gt; - the name of the remote user on the target server you want to connect with. NOTE: Default is your local machine username echo ${USER} IdentifyFile \u0026lt;/path/to/identity_file\u0026gt; - this is the path to the private key you use to connect to the target server. NOTE: Default is ~/.ssh/id_rsa or an iteration of the files within ~/.ssh directory ProxyJump \u0026lt;[host|ip]_of_jump_server\u0026gt; - if you want to connect to the target server using a jump server, you should specify its DNS host or IP address here. There is a ton of other options which you can explore here\nUsage and Access # :) - My SSH life begins again ssh test # ;) - This time way easier ssh ci # X) So easy that I may run \u0026#39;rm -rf /*\u0026#39; to spice it up a bit ssh prod If you have configured everything properly you should be connected to the target server with a clean and easy-to-remember CLI. 🎊\nTroubleshooting In case the setup does not work, there are a few things you can inspect:\n✏️ Make sure you saved ~/.ssh/config 🔎 Check for typos within the ~/.ssh/config ☎️ If using DNS records for hostname configuration, inspect whether your local setup can resolve them nslookup \u0026lt;host\u0026gt; 🔌 If you are not sure whether the configured port is open you can always run nc -G 1 \u0026lt;host|ip\u0026gt; \u0026lt;port\u0026gt;, where -G 1 is one second of timeout. If the operation times out, most probably the port is not open. 🖨️ Check for network access to the target server ping \u0026lt;host\u0026gt;. NOTE: Sometimes admins disable ping, so it may not work. You can use traceroute or nc in that case. 🔓 In case of WARNING: UNPROTECTED PRIVATE KEY FILE! run chmod 0600 /path/to/private/key Wrap-up In the beginning, it may seem an overkill to maintain your SSH config file. But with time and exposure to more servers you will eventually end up using SSH config anyway.\nIn the end - What if you want to create another host for access. Just repeat the steps above and enjoy your day! 🎉\nPS: If you have a friend who struggles with SSH you can always share it with the links down-below ⬇️\nBest! 🦷\n","permalink":"https://thetooth.io/blog/ssh_access/","summary":"If you are landing on this page you probably already know what SSH is and how to use it through CLI. If not, take a quick look here. In general, SSH is the most common tool people use to connect to remote systems and servers.\nUsually, in the beginning, a user starts with simple ssh \u0026lt;user\u0026gt;@\u0026lt;host\u0026gt; CLI usage. With time, using more and more advanced options, the commands become lengthy and clumsy resulting in a mess that is hard or impossible to remember.","title":"SSH access made easy 📟"},{"content":"Init blogpost 🎬\necho Hello World 🦷 ","permalink":"https://thetooth.io/blog/thebeginning/","summary":"Init blogpost 🎬\necho Hello World 🦷 ","title":"The Beginning 🎬"}]