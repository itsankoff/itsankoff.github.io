[{"content":"Apart from being the cutest animal in the world üòç, Slowloris is also a low-bandwidth application layer Denial-of-Service (DoS) attack running on Application layer of the OSI model (OSI Layer 7). The attack allows the attacker to overwhelm a target HTTP server by exploiting the internals of the HTTP protocol.\nHow normal HTTP request-response works? In normal scenario the client opens a TCP connection after which it sends the text information for the request. Each of the request\u0026rsquo;s lines are terminated by \\r\\n (so-called CRLF - carriage return line feed ‚å®Ô∏è) sequence. The end of the request is signaled by \\r\\n\\r\\n.\nClient (Alice) sends an HTTP GET request to a HTTP Server (Bob) The first line in the HTTP request is called request line holding information about the HTTP request method GET, path / and query parameters as well as protocol version HTTP/1.1. Then the client starts sending the request headers - Host: example.com, User-Agent: ... and so on. In the end the client sends \\r\\n\\r\\n to notify the server that the request is done.\nHow does a Slowloris attack works? Slowloris attack works by utilizing partial HTTP requests. HTTP protocol works as opening a client TCP connection to a target server and then sends the HTTP request. The server usually waits until it receives the \\r\\n\\r\\n sequence to process the request. Here comes the attack exploit. The attacker can send multiple headers (thousands) to keep the connection open. By opening multiple such connections and regularly sending partial information (such as headers) the memory and sockets start building up on the server side. This way the client can easily exhaust server\u0026rsquo;s available resources (ports, sockets and memory). Once the server\u0026rsquo;s maximum connections has been exceeded, each new connection won\u0026rsquo;t be answered and denial-of-service will occur. Server configurations Usually HTTP servers support configuration of parameters like running workers/threads, maximum open connections, timeouts and so on. The problem comes when a server runs with the defaults parameters or it is inherently exposed to such attack by its internal implementation.\nApache server Apache server implementation is a thead-based implementation which is inherently vulnerable to attacks like slowloris. The problem comes with that the OS defines number of of maximum threads for each process. The numbers nowadays are pretty big cat /proc/sys/kernel/threads-max but still if you don\u0026rsquo;t have access to kernel configuration that may be an issue. Another problem is memory footprint. Each OS thread is associated with memory and also there are restrictions of maximum Virtual Memory Areas (VMAs) per process cat /proc/sys/vm/max_map_count. So you see how not-well configured Apache server can be exposed to slowloris attack.\nNginx server Difference here is that nginx implementation relies on event based system which saves the server from attacks such slowloris. But the problem may come from having nginx running its default configuration. Nowadays nginx comes with default configuration that is pretty obsolete and it is usually vulnerable to slowloris attack.\nWant to play with slowloris If you want to explore whether some of your deployments are vulnerable or susceptible to slowloris attack, I\u0026rsquo;ve created a distributed Golang implementation. The tools is able to run thousands of parallel slowloris connections against a target server. You can download it and find more in the ü™£ repo\nIn the next article we will look at how to protect from such attacks.\nBest! ü¶∑\n","permalink":"https://thetooth.io/blog/slowloris-attack/","summary":"Apart from being the cutest animal in the world üòç, Slowloris is also a low-bandwidth application layer Denial-of-Service (DoS) attack running on Application layer of the OSI model (OSI Layer 7). The attack allows the attacker to overwhelm a target HTTP server by exploiting the internals of the HTTP protocol.\nHow normal HTTP request-response works? In normal scenario the client opens a TCP connection after which it sends the text information for the request.","title":"Slowloris Attack ü¶• "},{"content":"If you are landing on this page you probably already know what SSH is and how to use it through CLI. If not, take a quick look here. In general SSH is the most common tool people use to connect to remote systems and servers.\nUsually, in the beginning, people start with simple ssh \u0026lt;user\u0026gt;@\u0026lt;host\u0026gt; CLI usage. With time, using more and more advanced options, the commands become lengthy and clumsy resulting in a mess that are hard or impossible to remember.\nLet\u0026rsquo;s give you an example:\n# My SSH life begins here ssh user@host # That was easy :) # Then some person decides to enforce security through obscurity ssh user@this.is.a.super.long.host.that.is.hard.to.remember.private.com # Eh mate, you can do better ;) # Then the same person decides to change the default port ssh -p 43571 user@this.is.a.super.long.host.that.is.hard.to.remember.private.com # I am pretty good at numerology X) # That\u0026#39;s not enough, so let\u0026#39;s disable password auth and # enforce public/private key authentication only ssh -p 43571 -i /where/the/heck/is/my/private/key user@this.is.a.super.long.host.that.is.hard.to.remember.private.com # Grr... :| # somebody from the infra team: # \u0026#34;Mmm, the security team asked us to put everything in a private network # and you will need an access the server through our jump server\u0026#34; ssh -J jumbo@this.is.another.obscure.host.private.jump.com:62891 -i /where/the/heck/is/my/private/key -p 43571 user@this.is.a.super.long.host.that.is.hard.to.remember.private.com # Just shut up and teach me about the SSH config file! :@ Remembering dictionary information nowadays should be considered a crime! So what you can do to make yourself a proper citizen of the world?\nSSH config on the rescue SSH utilities have a metaverse of options and tools, so let\u0026rsquo;s try to utilize them and simplify our work! One of them is the SSH config. The SSH config is a configurational file, usually stored at ~/.ssh/config where you can pre-configure hosts and access configuration that you use frequently and simplify the access shown above to:\n# access the \u0026#39;this.is.a.super.long.host.that.is.hard.to.remember.private.com\u0026#39; ssh test # access the non-default-port (43571) on you-know-which-host ssh ci # access the production for f@ck sake! ssh prod Setup  Check whether you have ~/.ssh/config on your local setup. If the file does not exist, let\u0026rsquo;s create it! NOTE: ~(tilda) means the home directory of the current user. Open the file with a text editor (vim, emacs, VSCode, nano, etc\u0026hellip;) Write down:  Host \u0026lt;alias\u0026gt; Hostname \u0026lt;[host|ip]\u0026gt; # mandatory Port \u0026lt;port\u0026gt; # optional User \u0026lt;username\u0026gt; # optional | nice-to-have IdentityFile \u0026lt;path/to/identity_file\u0026gt; # optional | nice-to-have ProxyJump \u0026lt;[host|ip]_of_jump_server\u0026gt; # optional Replace the mandatory placeholders and remove the unused ones Save the file  Where:\n Hostname \u0026lt;[host|ip]\u0026gt; - the DNS host or IP address of the target server Port \u0026lt;port\u0026gt; - you can skip this if the target server runs SSH on the default 22 port. Otherwise, you will need to state it User \u0026lt;username\u0026gt; - the name of the remote user on the target server you want to connect with. NOTE: Default is your local machine username IdentifyFile \u0026lt;/path/to/identity_file\u0026gt; - this is the path to the private key you use to connect to the target server. NOTE: Default is ~/.ssh/id_rsa or an iteration of the files within ~/.ssh directory ProxyJump \u0026lt;[host|ip]_of_jump_server - if you want to connect to a target server using a jump server, you should specify its DNS host or IP address here.  There are a ton of other options which you can explore here\nUsage and Access # My SSH life begins again ssh test # This time way easier ssh ci # So easy that I may run \u0026#39;rm -rf /*\u0026#39; to spice it up a bit ssh prod If you have configured everything properly you should be connected to the target server with a clean and easy-to-remember CLI. üéä\nTroubleshooting In case the setup does not work, there are a few things you can inspect:\n ‚úèÔ∏è Make sure you saved ~/.ssh/config üîé Check for typos within the ~/.ssh/config ‚òéÔ∏è If using DNS records for hostname configuration, inspect whether your setup can resolve them nslookup \u0026lt;host\u0026gt; üîå If you are not sure whether the configured port is open you can always run nc -G 1 \u0026lt;host|ip\u0026gt; \u0026lt;port\u0026gt;, where -G 1 is one second of timeout. If the operation times out, most probably the port is not open. üñ®Ô∏è Check for network access to the target server ping \u0026lt;host\u0026gt;. NOTE: Sometimes admins disable ping, so it may not work. You can use traceroute in that case. üîì In case of WARNING: UNPROTECTED PRIVATE KEY FILE! run chmod 0600 /path/to/private/key  Wrap-up In the beginning, it may seems an overkill to maintain your SSH config file. But with time and exposure to more servers you will eventually end up using SSH config anyway.\nIn the end - What if you want to create another host for access. Just repeat the steps above and enjoy your day! üéâ\n PS: If you have a friend who is struggling with SSH you can always share it with the links down-below ‚¨áÔ∏è\n","permalink":"https://thetooth.io/blog/ssh_access/","summary":"If you are landing on this page you probably already know what SSH is and how to use it through CLI. If not, take a quick look here. In general SSH is the most common tool people use to connect to remote systems and servers.\nUsually, in the beginning, people start with simple ssh \u0026lt;user\u0026gt;@\u0026lt;host\u0026gt; CLI usage. With time, using more and more advanced options, the commands become lengthy and clumsy resulting in a mess that are hard or impossible to remember.","title":"SSH access made easy üìü"},{"content":"Init blogpost üé¨\necho Hello World ü¶∑ ","permalink":"https://thetooth.io/blog/thebeginning/","summary":"Init blogpost üé¨\necho Hello World ü¶∑ ","title":"The Beginning üé¨"}]